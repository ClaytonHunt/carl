# CARL State File Template
# This template is used to generate consistent .state files for tracking implementation progress

feature_id: {feature_id}
last_updated: {update_timestamp}
phase: {current_phase}  # planning, development, testing, staging, production
completion_percentage: {completion_percent}

implementation:
  completed:
    - component: "{component_name}"
      file: "{file_path}"
      implementation_date: "{completion_date}"
      tests: "{test_types}"  # unit, integration, e2e
      coverage: {test_coverage_percent}
      quality_score: {quality_score}
      performance_metrics: "{performance_data}"
  
  in_progress:
    - component: "{component_name}"
      file: "{file_path}"
      progress: {progress_percent}
      assigned_to: "{developer_name}"
      started_date: "{start_date}"
      estimated_completion: "{eta_date}"
      blockers: [{blocker_list}]
      notes: "{implementation_notes}"
  
  planned:
    - component: "{component_name}"
      estimated_file: "{planned_file_path}"
      priority: "{priority_level}"
      effort_estimate: "{time_estimate}"
      dependencies: [{dependency_list}]
      assigned_to: "{planned_developer}"

technical_debt:
  debt_items:
    - id: "{debt_item_id}"
      type: "{debt_type}"  # code_quality, architectural, documentation, test_coverage
      description: "{debt_description}"
      location: "{file_path_or_component}"
      severity: "{high|medium|low}"
      effort_to_fix: "{fix_effort_estimate}"
      business_impact: "{impact_description}"
      created_date: "{creation_date}"
      status: "{new|acknowledged|planned|in_progress|resolved}"

quality_metrics:
  test_coverage:
    unit_tests: {unit_coverage_percent}
    integration_tests: {integration_coverage_percent}
    e2e_tests: {e2e_coverage_percent}
    overall_coverage: {total_coverage_percent}
  
  code_quality:
    complexity_score: {complexity_rating}
    maintainability_index: {maintainability_score}
    duplication_percentage: {code_duplication_percent}
    security_issues: {security_issue_count}
    performance_score: {performance_rating}
  
  defect_metrics:
    open_bugs: {bug_count}
    critical_issues: {critical_issue_count}
    bug_resolution_time: "{average_resolution_time}"
    regression_rate: {regression_percentage}

performance_data:
  response_times:
    average: "{avg_response_time}"
    p95: "{p95_response_time}"
    p99: "{p99_response_time}"
  
  resource_usage:
    cpu_utilization: {cpu_percent}
    memory_usage: "{memory_usage}"
    database_query_time: "{db_query_time}"
  
  scalability:
    concurrent_users_supported: {user_capacity}
    throughput: "{requests_per_second}"
    bottlenecks: [{bottleneck_list}]

deployment_status:
  environments:
    development:
      status: "{deployed|not_deployed|failed}"
      version: "{version_number}"
      deployment_date: "{deployment_timestamp}"
      health_check: "{passing|failing|unknown}"
    
    staging:
      status: "{deployed|not_deployed|failed}"
      version: "{version_number}"
      deployment_date: "{deployment_timestamp}"
      health_check: "{passing|failing|unknown}"
    
    production:
      status: "{deployed|not_deployed|failed}"
      version: "{version_number}"
      deployment_date: "{deployment_timestamp}"
      health_check: "{passing|failing|unknown}"

validation_results:
  requirements_validation:
    - requirement: "{requirement_description}"
      status: "{satisfied|partially_satisfied|not_satisfied}"
      validation_method: "{validation_approach}"
      validation_date: "{validation_timestamp}"
      notes: "{validation_notes}"
  
  acceptance_criteria:
    - criterion: "{acceptance_criterion}"
      status: "{passed|failed|pending}"
      test_method: "{test_approach}"
      validation_date: "{test_timestamp}"
      evidence: "{test_evidence}"

team_metrics:
  development_velocity:
    story_points_completed: {completed_points}
    features_delivered: {feature_count}
    average_cycle_time: "{cycle_time}"
    lead_time: "{lead_time}"
  
  collaboration_metrics:
    code_review_turnaround: "{review_time}"
    pair_programming_hours: {pairing_hours}
    knowledge_sharing_sessions: {session_count}

session_tracking:
  recent_sessions:
    - session_id: "{session_identifier}"
      date: "{session_date}"
      duration: "{session_duration}"
      work_completed: "{work_summary}"
      developer: "{developer_name}"
      milestone_achieved: "{milestone_description}"
  
  active_work:
    current_session: "{current_session_id}"
    active_since: "{session_start_time}"
    current_focus: "{current_work_item}"
    estimated_completion: "{eta_current_work}"

continuous_integration:
  build_status:
    last_build: "{build_status}"  # success, failure, in_progress
    build_number: {build_number}
    build_duration: "{build_time}"
    build_timestamp: "{build_date}"
  
  test_automation:
    automated_test_count: {test_count}
    test_execution_time: "{test_duration}"
    test_success_rate: {success_percentage}
    flaky_test_count: {flaky_tests}

# Change tracking
recent_changes:
  - change_type: "{addition|modification|deletion}"
    description: "{change_description}"
    files_affected: [{file_list}]
    change_date: "{change_timestamp}"
    developer: "{developer_name}"
    impact: "{change_impact}"

# Next steps and recommendations
next_steps:
  immediate_actions:
    - action: "{action_description}"
      priority: "{high|medium|low}"
      estimated_effort: "{time_estimate}"
      assigned_to: "{developer_name}"
  
  upcoming_milestones:
    - milestone: "{milestone_name}"
      target_date: "{milestone_date}"
      completion_criteria: [{criteria_list}]
      risk_level: "{high|medium|low}"

# Metadata
state_version: {state_file_version}
generated_by: "{carl_system_version}"
last_analysis: {last_analysis_timestamp}
next_review_date: {next_review_date}